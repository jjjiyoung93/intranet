<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="stdMng">	
	
	<!-- 여비정보 리스트 조회  -->
	<select id="get00List" resultType="HashMap" parameterType="map" >
		SELECT A.GROUP_CD
			 , A.TRVCT
       		 , B.CD_NM AS GROUP_NM
		  FROM STD_TRVCT_GROUP A
	      LEFT OUTER JOIN
	      STD_CD_MNG B
	      ON(A.GROUP_CD = B.CD)
	      ORDER BY A.GROUP_CD
	</select>
	
	<!-- 여비정보 정보 상세보기  -->
	<select id="getView" resultType="HashMap" parameterType="map" >
		SELECT  A.GROUP_CD
			 , A.TRVCT
       		 , B.CD_NM AS GROUP_NM
		  FROM STD_TRVCT_GROUP A
		  LEFT OUTER JOIN
	      STD_CD_MNG B
	      ON(A.GROUP_CD = B.CD)
		  where group_cd = #{group_cd}
	</select>
	
	<!-- 여비정보 갯수 조회  -->
	<select id="getGrpCnt" parameterType="map" resultType="HashMap" >
		SELECT COUNT(A.GROUP_CD) AS CNT
		  FROM STD_TRVCT_GROUP A 
		  LEFT OUTER JOIN STD_CD_MNG B ON (B.CD = A.GROUP_CD)
		 WHERE B.CD_NM = #{nm}	
	</select>

	<!-- 여비정보 등록 -->
	<insert id="insertGrp" parameterType="map">
		
		MERGE INTO STD_TRVCT_GROUP A
		USING
		      DUAL       
		   ON (A.GROUP_CD = #{CD})
		WHEN NOT MATCHED THEN
		INSERT (A.GROUP_CD, A.TRVCT)
		VALUES (
				 #{CD}	
				,#{trvct} )

		<!-- INSERT INTO STD_TRVCT_GROUP (
			    GROUP_CD
			  , TRVCT
			)VALUES(
			    #{CD}
			  , #{trvct}
			) -->
	</insert>
	
	<!-- 여비정보 수정 -->
	<update id="updateGrp"  parameterType="map">
		UPDATE  STD_TRVCT_GROUP
		   SET  TRVCT        = #{trvct}   
		 WHERE GROUP_CD = #{group_cd}
	</update>
	
	<!-- 여비 정보 삭제 -->
	<delete id="deleteGrp" parameterType="map">
		DELETE FROM STD_TRVCT_GROUP WHERE GROUP_CD = #{std_id}
	</delete>
	
	<!-- 여비정보 공통 코드 등록-->
	<insert id="insertGrpCd" parameterType="map">
		<selectKey keyProperty="CD" order="BEFORE" resultType="String">
			<!-- SELECT 'CD0012' || LPAD(COUNT(CD)+1, '3', '0') FROM STD_CD_MNG WHERE UP_CD = 'CD0012' -->
				SELECT 
				'CD0012' ||
				SUBSTR('000' || TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(cd,-3))),0)+1),-3)
			FROM STD_CD_MNG WHERE up_cd = 'CD0012'
		</selectKey>
		
		MERGE INTO STD_CD_MNG A
		USING (SELECT #{CD} AS NEW_CD
		            , #{grp_nm} AS GRP_NM
		            , 'CD0012' AS UP_CD
		            , '2' AS LEVL
		            , MAX(CD_ORD) +1 AS CD_ORD
		         FROM STD_CD_MNG
		        WHERE UP_CD = 'CD0012') C
		   ON (C.GRP_NM = A.CD_NM
		       AND C.UP_CD = A.UP_CD)
	    WHEN NOT MATCHED THEN
	    INSERT (A.CD, A.CD_NM, A.UP_CD, A.LEVL, A.CD_ORD)
	    VALUES (C.NEW_CD, C.GRP_NM, C.UP_CD, C.LEVL, C.CD_ORD) 
		
		<!-- INSERT INTO STD_CD_MNG
		(CD, CD_NM, UP_CD, LEVL, CD_ORD)
		SELECT
		       #{CD}
		     , #{grp_nm}
		     , 'CD0012'
		     , '2'
		     , MAX(CD_ORD) + 1
		  FROM STD_CD_MNG
		 WHERE UP_CD = 'CD0012' -->
	</insert>
	
	<!-- 여비정보 공통 코드 수정  -->
	<update id="updateGrpCd" parameterType="map">
		UPDATE STD_CD_MNG
		   SET CD_NM = #{grp_nm}
		 WHERE CD = #{CD}
	</update>
	
	<!-- 여비정보 공통 코드 삭제 -->
	<delete id="deleteGrpCd" parameterType="map">
		DELETE FROM STD_CD_MNG WHERE CD = #{std_id}
	</delete>
	
	
	<!-- 급수별 여비 개수 조회  -->
	<select id="getCnt00" parameterType="map" resultType="HashMap">
		SELECT COUNT(GROUP_CD) AS CNT FROM STD_TRVCT_GROUP WHERE GROUP_CD = #{cd}
	</select>
	
	
	
	<!-- 그룹별급수 리스트 조회  -->
	<select id="get01List" resultType="HashMap" parameterType="map" >
		SELECT A.AUTHOR_CODE
			 , A.GROUP_CD
       		 , B.AUTHOR_NM AS AUT_NM
       		 , B.AUTHOR_RSRCH_NM AS RSRCH_NM
       		 , D.CD_NM AS GROUP_NM
		  FROM STD_TRVCT_GROUP_AUT A
	      LEFT OUTER JOIN
	      STD_AUT_INFO B
	      ON(A.AUTHOR_CODE = B.AUTHOR_CODE)
	      LEFT OUTER JOIN
	      STD_TRVCT_GROUP C
	      ON(A.GROUP_CD = C.GROUP_CD)
	      LEFT OUTER JOIN
	      STD_CD_MNG D
	      ON(C.GROUP_CD = D.CD)
	      ORDER BY A.GROUP_CD, A.AUTHOR_CODE
	</select>
	
	<!-- 그룹별급수 정보 상세보기  -->
	<select id="getView2" resultType="HashMap" parameterType="map" >
		SELECT A.AUTHOR_CODE
			 , A.GROUP_CD
			 , B.AUTHOR_NM
			 , B.AUTHOR_RSRCH_NM
			 , C.CD_NM AS GROUP_NM
		  FROM STD_TRVCT_GROUP_AUT A
		  LEFT OUTER JOIN STD_AUT_INFO B ON(B.AUTHOR_CODE = A.AUTHOR_CODE)
		  LEFT OUTER JOIN STD_CD_MNG C ON (C.CD = A.GROUP_CD)
		  
		  where A.AUTHOR_CODE = #{aut_cd}
	</select>
	
	<!-- 그룹별급수 등록 -->
	<insert id="insertAut" parameterType="map">
		INSERT INTO STD_TRVCT_GROUP_AUT (
			    AUTHOR_CODE
			  , GROUP_CD
			)
		VALUES (#{autCode}, #{CD})
	</insert>
	
	<!-- 그룹별급수 수정 -->
	<update id="updateAut"  parameterType="map">
		UPDATE  STD_TRVCT_GROUP_AUT
		   SET  GROUP_CD        = #{group_cd}   
		 WHERE AUTHOR_CODE = #{aut_cd}
	</update>
	
	<!-- 연구 직급 수정  -->
	<update id="updateRsrchNm" parameterType="map">
		UPDATE STD_AUT_INFO
		   SET AUTHOR_RSRCH_NM = #{author_rsrch_nm}
		 WHERE AUTHOR_CODE = #{aut_cd}
	</update>
	
	<!-- 그룹별급수 삭제 -->
	<delete id="deleteAut" parameterType="map">
		DELETE FROM STD_TRVCT_GROUP_AUT WHERE AUTHOR_CODE = #{std_id}
	</delete>
	
	<!-- 급수코드 참조하여 그룹별급수 삭제-->
	<delete id="deleteTrvctGrupAut" parameterType="map">
		DELETE FROM STD_TRVCT_GROUP_AUT WHERE GROUP_CD = #{std_id}
	</delete>
	
		
	<!-- 그룹별급수 갯수 조회  -->
	<select id="getCnt01" parameterType="map" resultType="HashMap">
		SELECT COUNT(A.AUTHOR_CODE) AS CNT
		  FROM STD_TRVCT_GROUP_AUT A
		 <!-- LEFT OUTER JOIN STD_CD_MNG B ON (B.CD = A.GROUP_CD) -->
		 LEFT OUTER JOIN STD_AUT_INFO C ON (C.AUTHOR_CODE = A.AUTHOR_CODE)
		 <!-- WHERE B.CD_NM = #{groupNm} -->
		WHERE C.AUTHOR_NM = #{authorNm}
	</select>
	
	
	<!-- 그룹(권한구분)코드 추가  -->
	<insert id="insertAutCd" parameterType="map">
	
		<selectKey keyProperty="NEW_CD" order="BEFORE" resultType="String">
			<!-- SELECT 'CD0006' || LPAD(COUNT(CD)+1, '3', '0') FROM STD_CD_MNG WHERE UP_CD = 'CD0006' -->
				SELECT 
				'CD0006' ||
				SUBSTR('000' || TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(cd,-3))),0)+1),-3)
			FROM STD_CD_MNG WHERE up_cd = 'CD0006'
		</selectKey>
	
		MERGE INTO STD_CD_MNG A
		USING (SELECT #{NEW_CD} AS NEW_CD
		            , #{author_nm} AS AUT_NM
		            , 'CD0006' AS UP_CD
		            ,  '2' AS LEVL
		            ,  MAX(CD_ORD) +1 AS CD_ORD
		         FROM STD_CD_MNG
		        WHERE UP_CD = 'CD0006') C
		   ON ( A.CD_NM = C.AUT_NM
		       AND A.UP_CD = C.UP_CD )
		WHEN NOT MATCHED THEN
		INSERT (A.CD, A.CD_NM, A.UP_CD, A.LEVL, A.CD_ORD)
		VALUES (C.NEW_CD, C.AUT_NM, C.UP_CD, C.LEVL, C.CD_ORD)
	</insert>
	
	<!-- 그룹(권한구분) 코드 가져오기  -->
	
	<select id="getAutCdView" resultType="HashMap" parameterType="map" >
		SELECT cd
		     ,cd_nm
		     ,up_cd
		     ,levl
		     ,cd_ord
		     ,cd_val
		FROM STD_CD_MNG
		WHERE cd_nm = #{author_nm, javaType=String ,jdbcType=VARCHAR}
		  AND up_cd = 'CD0006'
	</select>

	<!-- 급수 코드 가져오기  -->
	
	<select id="getGrpCdView" resultType="HashMap" parameterType="map" >
		SELECT cd
		     ,cd_nm
		     ,up_cd
		     ,levl
		     ,cd_ord
		     ,cd_val
		FROM STD_CD_MNG
		WHERE cd_nm = #{grp_nm, javaType=String ,jdbcType=VARCHAR}
		  AND up_cd = 'CD0012'
	</select>
	
	<!-- 권한 정보 가져오기 STD_AUT_INFO  -->
	
	<select id="getAuthInfoView" resultType="HashMap" parameterType="map" >
		SELECT AUTHOR_CODE
		     , AUTHOR_NM
		   	 , AUTHOR_DC
		     , AUTHOR_CREAT_DE
		     , CD_MAP
		     , AUTHOR_RSRCH_NM
		FROM STD_AUT_INFO
		WHERE AUTHOR_NM = #{author_nm, javaType=String ,jdbcType=VARCHAR}
	</select>
	
	
	<!-- 그룹(직급) 정보 추가 -->
	<insert id="insertAutInfo" parameterType="map">
		
		<selectKey keyProperty="NEW_AUT_CD" order="BEFORE" resultType="String">
			SELECT 'ROLE_USER'||TRIM(TO_CHAR(MAX(SUBSTR(AUTHOR_CODE,10))+1, '00')) FROM STD_AUT_INFO WHERE AUTHOR_CODE LIKE 'ROLE_USER__'
		</selectKey>
		
		MERGE INTO STD_AUT_INFO A
		USING (
				SELECT #{NEW_AUT_CD} AS AUT_CD
				     , #{author_nm} AS AUT_NM
				     , TO_CHAR(SYSDATE, 'YY/MM/DD') AS DT
				     , #{NEW_CD} AS NEW_CD
				     , #{author_rsrch_nm} AS RSRCH_NM
				  FROM DUAL )C
		  ON (C.AUT_NM = A.AUTHOR_NM)
		WHEN NOT MATCHED THEN
		INSERT (A.AUTHOR_CODE, A.AUTHOR_NM, A.AUTHOR_CREAT_DE, A.CD_MAP, A.AUTHOR_RSRCH_NM)
		VALUES (C.AUT_CD
		       , C.AUT_NM
		       , C.DT
		       <choose>
		       	<when test="@kr.letech.cmm.util.DBSupport@isNotEmpty(OLD_CD)">
		       		, #{OLD_CD}
		       	</when>
		       	<otherwise>
			       , C.NEW_CD		       		
		       	</otherwise>
		       </choose>
		       , C.RSRCH_NM)
		WHEN MATCHED THEN
		UPDATE SET AUTHOR_RSRCH_NM = #{author_rsrch_nm}
	</insert>
	
	<!-- 그룹 코드 CD_VAL 수정  -->
	<update id="updateAutCd" parameterType="map">
		UPDATE STD_CD_MNG
		   SET CD_VAL = #{autCode}
		  WHERE CD = 
		  <choose>
		       	<when test="@kr.letech.cmm.util.DBSupport@isNotEmpty(OLD_CD)">
		       		#{OLD_CD}
		       	</when>
		       	<otherwise>
			        #{NEW_CD}		       		
		       	</otherwise>
		 </choose>
	</update>
	
	
	<!-- 관한 상속 관계 추가  -->
	<insert id="insertRoleHic" parameterType="map">
		MERGE INTO STD_AUT_ROLE_HIC A
		USING DUAL
		   ON (A.PARNTS_ROLE = 'ROLE_USER'
		       AND A.CHLDRN_ROLE = #{autCode})
		WHEN NOT MATCHED THEN
		INSERT (A.PARNTS_ROLE, A.CHLDRN_ROLE)
		VALUES ('ROLE_USER', #{autCode})
	</insert>
	
	
	
	
	
	<!-- 교통비 리스트 조회  -->
	<select id="get02List" resultType="HashMap" parameterType="map" >
		SELECT A.REGN_CD1
			 , A.REGN_CD2
       		 , B.CD_NM AS REGN_NM1
       		 , C.CD_NM AS REGN_NM2
       		 , A.DSTNC
       		 , A.TRCS
       		 , TO_CHAR(A.DSTNC, '999,999,999,999,990.99') AS DSTNC_FORM
       		 , TO_CHAR(A.TRCS, '999,999,999,999,999') AS TRCS_FORM
		  FROM STD_TRCS A
	      LEFT OUTER JOIN
	      STD_CD_MNG B
	      ON(A.REGN_CD1 = B.CD)
	      LEFT OUTER JOIN
	      STD_CD_MNG C
	      ON(A.REGN_CD2 = C.CD)
	   WHERE 1=1
	   <if test="@kr.letech.cmm.util.DBSupport@isNotEmpty(regnCd)" >
		 AND A.REGN_CD1 = #{regnCd}
	   </if>
	      
	      ORDER BY A.REGN_CD1, A.REGN_CD2
	</select>
	
	<!-- 교통비 정보 상세보기  -->
	<select id="getView3" resultType="HashMap" parameterType="map" >
		SELECT  A.REGN_CD1
			 , A.REGN_CD2
       		 , A.DSTNC
       		 , A.TRCS
       		 , B.CD_NM AS REGN_NM1
       		 , C.CD_NM AS REGN_NM2
		  FROM STD_TRCS A
		  LEFT OUTER JOIN
	      STD_CD_MNG B
	      ON(A.REGN_CD1 = B.CD)
	      LEFT OUTER JOIN
	      STD_CD_MNG C
	      ON(A.REGN_CD2 = C.CD)
	    WHERE A.REGN_CD1 = #{regn_cd1}
		  AND A.REGN_CD2 = #{regn_cd2}
	</select>
	
	<!-- 교통비 등록 -->
	<insert id="insertTrcs" parameterType="map">
		MERGE INTO STD_TRCS A
		USING DUAL
		   ON (A.REGN_CD1 = #{trvctVO.regnCd1}
		   AND A.REGN_CD2 = #{trvctVO.regnCd2})
		WHEN NOT MATCHED THEN
		
		INSERT (A.REGN_CD1, A.REGN_CD2, A.DSTNC, A.TRCS)
		VALUES (#{trvctVO.regnCd1}, #{trvctVO.regnCd2}, #{trvctVO.dstnc}, #{trvctVO.trcs})
	
		<!-- INSERT INTO STD_TRCS (
			    REGN_CD1
			  , REGN_CD2
			  , DSTNC
			  , TRCS
			)VALUES(
			    #{trvctVO.regnCd1}
			  , #{trvctVO.regnCd2}
			  , #{trvctVO.dstnc}
			  , #{trvctVO.trcs}
			) -->
	</insert>
	
	
	<!-- 출장지역  공통 코드 등록-->
	<insert id="insertTrcsCd" parameterType="map">
		<selectKey keyProperty="cd" order="BEFORE" resultType="String">
			SELECT 
				'CD0009' ||
				SUBSTR('000' || TO_CHAR(NVL(MAX(TO_NUMBER(SUBSTR(cd,-3))),0)+1),-3)
			FROM STD_CD_MNG WHERE up_cd = 'CD0009'
		</selectKey>
		
		MERGE INTO STD_CD_MNG A
		USING (SELECT #{cd} AS NEW_CD
		            , #{cd_nm} AS CD_NM
		            , 'CD0009' AS UP_CD
		            , '2' AS LEVL
		            , MAX(CD_ORD) +1 AS CD_ORD
		         FROM STD_CD_MNG
		        WHERE UP_CD = 'CD0009') C
		   ON (C.CD_NM = A.CD_NM
		       AND C.UP_CD = A.UP_CD)
	    WHEN NOT MATCHED THEN
	    INSERT (A.CD, A.CD_NM, A.UP_CD, A.LEVL, A.CD_ORD)
	    VALUES (C.NEW_CD, C.CD_NM, C.UP_CD, C.LEVL, C.CD_ORD) 
	    
	  </insert>
	  
	  
	  <!-- 급수 코드 가져오기  -->
	
	<select id="getTrcsCdView" resultType="HashMap" parameterType="map" >
		SELECT cd
		     ,cd_nm
		     ,up_cd
		     ,levl
		     ,cd_ord
		     ,cd_val
		FROM STD_CD_MNG
		WHERE cd_nm = #{cd_nm, javaType=String ,jdbcType=VARCHAR}
		  AND up_cd = 'CD0009'
	</select>
	
	
	
	<!-- 교통비 수정 -->
	<insert id="updateTrcs"  parameterType="map">
	
		
	<!-- merge 문으로 바꿀 것  -->
		MERGE INTO STD_TRCS A
		USING DUAL
		   ON (    A.REGN_CD1 = #{trvctVO.regnCd1}
		       AND A.REGN_CD2 = #{trvctVO.regnCd2} )
		WHEN MATCHED THEN
		UPDATE 
		   SET A.DSTNC = #{trvctVO.dstnc}
		     , A.TRCS = #{trvctVO.trcs}
		WHEN NOT MATCHED THEN
		INSERT ( A.REGN_CD1
		       , A.REGN_CD2
		       , A.DSTNC
		       , A.TRCS )
		VALUES ( #{trvctVO.regnCd1}
		       , #{trvctVO.regnCd2}
		       , #{trvctVO.dstnc}
		       , #{trvctVO.trcs} ) 
	</insert>
	
	<!-- 교통비 삭제 -->
	<delete id="deleteTrcs" parameterType="map">
		DELETE FROM STD_TRCS WHERE REGN_CD1 = #{std_id} OR REGN_CD2 = #{std_id}
	</delete>
	
	<!-- 권한 그룹 조회  -->
	<select id="getAuthorList" parameterType="map" resultType="HashMap">
		SELECT AUTHOR_CODE AS CD
		     , AUTHOR_NM AS CD_NM
		     , AUTHOR_DC
		     , AUTHOR_CREAT_DE
		     , CD_MAP
		     , AUTHOR_RSRCH_NM
		  FROM STD_AUT_INFO
		 WHERE AUTHOR_CODE LIKE #{author_code} || '%'
	</select>
	
	<!-- 추가 지역 목록 조회  -->
	<select id="getAddList" resultType="HashMap" parameterType="map" >
		SELECT
		       CD
		      ,CD_NM
		      ,CD_ORD
		      ,CD_VAL
		      ,UP_CD
		  FROM STD_CD_MNG A
		 WHERE A.CD NOT IN (SELECT
		                           REGN_CD2
		                      FROM
		                           STD_TRCS
		                     WHERE REGN_CD1 = #{cd})
		    AND A.CD != #{cd}
		    AND A.UP_CD = #{up_cd}
	</select>
	
	<!-- 교통비 정보 갯수 조회  -->
	<select id="getRegnCnt" resultType="HashMap" parameterType="map" >
		SELECT COUNT(A.REGN_CD1) AS REGN_CNT
          FROM STD_TRCS A
          LEFT OUTER JOIN STD_CD_MNG B ON (B.CD = A.REGN_CD1 OR B.CD = A.REGN_CD2)
         WHERE B.CD_NM = #{cd_nm}
	</select>
	
	<!-- 지역 코드 조회  -->
	<select id="getTrcsCdList" resultType="HashMap" parameterType="map">
		SELECT COUNT(A.REGN_CD1) AS CNT
             , B.CD
             , B.CD_NM
             , B.CD_ORD
          FROM STD_TRCS A
         LEFT OUTER JOIN STD_CD_MNG B ON (B.CD = A.REGN_CD1)
         WHERE B.UP_CD = #{up_cd}
         GROUP BY B.CD, B.CD_NM, B.CD_ORD
         ORDER BY B.CD_ORD
	</select>
	
</mapper>
